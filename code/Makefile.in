
TURBINE_VERSION = @TURBINE_VERSION@

ENABLE_SHARED = @ENABLE_SHARED@
ENABLE_STATIC = @ENABLE_STATIC@

PACKAGE = lib/pkgIndex.tcl
PACKAGE_STATIC = libstatic/pkgIndex.tcl
ENABLED_PACKAGES :=

BUILD_ALL_TARGETS = libs executables
# BUILD_ALL_TARGETS = libs executables

ifeq ($(ENABLE_SHARED),1)
# Shared libraries are required for tcl package
  BUILD_ALL_TARGETS += package
  ENABLED_PACKAGES += $(PACKAGE)
endif

ifeq ($(ENABLE_STATIC),1)
# Shared libraries are required for tcl package
  BUILD_ALL_TARGETS += package_static
  ENABLED_PACKAGES += $(PACKAGE_STATIC)
endif

all: $(BUILD_ALL_TARGETS)

turbine: $(TURBINE)

package: $(PACKAGE)

package_static: $(PACKAGE_STATIC)

USE_MAC = @USE_MAC@

INSTALL_PREFIX  = @prefix@
INSTALL_BIN     = $(INSTALL_PREFIX)/bin
INSTALL_ETC     = $(INSTALL_PREFIX)/etc
INSTALL_INCLUDE = $(INSTALL_PREFIX)/include
INSTALL_LIB     = $(INSTALL_PREFIX)/lib
INSTALL_LIBSTATIC = $(INSTALL_PREFIX)/libstatic
INSTALL_SCRIPTS = $(INSTALL_PREFIX)/scripts
INSTALL_EXPORT  = $(INSTALL_PREFIX)/export
# The submit scripts are loaded from their respective module.mk files
SCRIPTS_SUBMIT  :=

SYSTEM_LIBS = $(shell cat system-libs.txt)

ifeq (@ENABLE_DEV@,1)
	WARN_CONVERSION = -Wconversion
endif

# Shared object suffix is .so on Linux, .dylib on Mac
# GCC shared library creation argument
# Linux: -shared; Mac: -dynamiclib
# Use -flat_namespace on the Mac
ifeq ($(USE_MAC),no)
	USE_XLC = @USE_XLC@
	ifeq ($(USE_XLC),0)
#       	Not XLC: GCC/Linux
		PIC = -fPIC
		STD = -std=gnu99
		SHARED = -shared
		WARNS = -Wall $(WARN_CONVERSION)
	else
#       	Using XLC
		PIC = -qpic
		STD =
		SHARED = -qmkshrobj -qnostaticlink -qnostaticlink=libgcc
		WARNS =
	endif

	SO_SUFFIX = so
	MAC_FLAT =
	MAC_NAME =
else
# 	Mac
	STD = -std=gnu99
	SO_SUFFIX = dylib
	MAC_FLAT = -Wl,-flat_namespace
	MAC_NAME = -install_name $(INSTALL_LIB)/libtclturbine.dylib
	SHARED = -dynamiclib $(MAC_FLAT)
endif

TCL_TURBINE_LIB := tclturbine
TCL_TURBINE_SO = lib/lib$(TCL_TURBINE_LIB).$(SO_SUFFIX)

# Static library
TCL_TURBINE_A = lib/lib$(TCL_TURBINE_LIB).a

# Static library for static-linking specific functions
STATIC_PKG_LIB := tclturbinestatic
STATIC_PKG_A := lib/lib$(STATIC_PKG_LIB).a

# Static library for resources like Tcl source
STATIC_PKG_RESOURCE_LIB := tclturbinestaticres
STATIC_PKG_RESOURCE_A := lib/lib$(STATIC_PKG_RESOURCE_LIB).a

TCL_TURBINE_LIBS :=
ifeq ($(ENABLE_SHARED),1)
  TCL_TURBINE_LIBS += $(TCL_TURBINE_SO)
endif

ifeq ($(ENABLE_STATIC),1)
  TCL_TURBINE_LIBS += $(TCL_TURBINE_A)
  TCL_TURBINE_LIBS += $(STATIC_PKG_A)
  TCL_TURBINE_LIBS += $(STATIC_PKG_RESOURCE_A)
endif

libs: $(TCL_TURBINE_LIBS)

srcdir = @srcdir@

ifeq ($(V),1)
	QUIET_COMPILE = 0
else
	QUIET_COMPILE = 1
endif

ifeq ($(QUIET_COMPILE),1)
  # Prints a short description of the action, does not show command
  Q=@echo
  E=@
else
  # Echoes the entire command
  Q=@echo >/dev/null
  E=
endif

CC = @CC@
CFLAGS := @CFLAGS@

# Set includes
CFLAGS += -I . -I src/turbine -I src/tcl/turbine -I src/tcl/static-pkg/
ifeq ($(USE_XLC),1)
	CFLAGS += -qpack_semantic=gnu
endif

AR      = @AR@
ARFLAGS = cr
RANLIB  = @RANLIB@

C_UTILS = @USE_C_UTILS@

TCL := @USE_TCL@
TCL_VERSION := @TCL_VERSION@
TCLSH := @USE_TCLSH@
TCL_LIB_DIR := @USE_TCL_LIB_DIR@
TCL_LIB_NAME := tcl$(TCL_VERSION)
TCL_LIB_SO := @USE_LIBTCL_SO@ 
TCL_LIB_A := @USE_LIBTCL_A@
TCLSH_LOCAL := @USE_TCLSH_LOCAL@

MKSTATIC := scripts/mkstatic/mkstatic.tcl
MKSTATIC_RUN := $(TCLSH_LOCAL) $(MKSTATIC)
MKSTATIC_TEMPLATE := scripts/mkstatic/mkstatic.c.template

MACHINE = @USE_MACHINE@

# On some systems, the user will use mpicc,
# on others, the user will specify the MPI include and lib paths
MPI_INCLUDE = @USE_MPI_INCLUDE@
MPI_LIB_DIR = @USE_MPI_LIB_DIR@
MPI_LIB_NAME = @USE_MPI_LIB_NAME@
# The actual linker arguments:
CFLAGS += -I $(MPI_INCLUDE)
MPI_LIB :=
ifeq ($(filter $(MPI_LIB_DIR),$(SYSTEM_LIBS)),)
  MPI_LIB += -L$(MPI_LIB_DIR)
endif
MPI_LIB	+= -l$(MPI_LIB_NAME)
           # -lmpl # Needed for older MPICH

LAUNCHER = @USE_LAUNCHER@

ADLB = @USE_ADLB@
ifneq ($(ADLB),0)
	CFLAGS += -I $(ADLB)/include
endif

ENABLE_MPE = @ENABLE_MPE@
USE_MPE = @USE_MPE@

ENABLE_XPT = @ENABLE_XPT@
ifeq ($(ENABLE_XPT),yes)
  CFLAGS += -D ENABLE_XPT
endif

HAVE_PYTHON        = @HAVE_PYTHON@
USE_PYTHON_INCLUDE = @USE_PYTHON_INCLUDE@
USE_PYTHON_LIBDIR  = @USE_PYTHON_LIBDIR@
USE_PYTHON_NAME    = @USE_PYTHON_NAME@

HAVE_R = @HAVE_R@
USE_R  = @USE_R@

CFLAGS += $(STD)
CFLAGS += -g
CFLAGS += $(WARNS)
ifeq ($(ENABLE_SHARED),1)
  CFLAGS += $(PIC)
endif
# This is referenced in lookup3.c - may want to drop this for speed
CFLAGS += -D VALGRIND
CFLAGS += -I $(C_UTILS)/include
CFLAGS += @TCL_INCLUDE_SPEC@
ifeq ($(ENABLE_MPE),1)
	CFLAGS += -I $(USE_MPE)/include
endif
ifeq ($(HAVE_PYTHON),1)
	CFLAGS += -I $(USE_PYTHON_INCLUDE)
endif
ifeq ($(HAVE_R),1)
	CFLAGS += -I $(USE_R)/include
endif

# LIBS: links to ADLB, c-utils, MPE, and MPI
LIBS :=
LIBS += -L$(ADLB)/lib -ladlb
LIBS += -L$(C_UTILS)/lib -lexmcutils
ifeq ($(filter $(TCL_LIB_DIR),$(SYSTEM_LIBS)),)
	LIBS += -L$(TCL_LIB_DIR)
endif
LIBS += -l$(TCL_LIB_NAME)
ifeq ($(ENABLE_MPE),1)
	LIBS += -L$(USE_MPE)/lib -lmpe
endif
LIBS += $(MPI_LIB)
ifeq ($(HAVE_PYTHON),1)
	ifneq ($(USE_PYTHON_LIBDIR),0)
		ifneq ($(USE_PYTHON_LIBDIR),)
			LIBS += -L$(USE_PYTHON_LIBDIR)
		endif
	endif
	LIBS += -l$(USE_PYTHON_NAME)
endif
ifeq ($(HAVE_R),1)
	R_LIB = $(USE_R)/lib
	LIBS += -L$(R_LIB) -lR
endif

# Transitive shared library dependencies, e.g. if we link against libtcl*.a
# TODO: more elegant solution
TRANSITIVE_LIB_DEPS_SHARED := -lpthread -ldl -lm
# Static dependencies are those where we generally can use the static
# library version even when dynamically linking a binary
TRANSITIVE_LIB_DEPS_STATIC := -lz 
TRANSITIVE_LIB_DEPS := $(TRANSITIVE_LIB_DEPS_SHARED) \
		       $(TRANSITIVE_LIB_DEPS_STATIC)

# If we are using libtcl*.a, need to always include these libraries
ifeq ($(strip $(TCL_LIB_SO)),)
	LIBS += $(TRANSITIVE_LIB_DEPS)
endif

dirname = $(patsubst %/,%,$(dir $(1)))

RPATHS :=
RPATHS += -Wl,-rpath -Wl,$(INSTALL_LIB)
RPATHS += -Wl,-rpath -Wl,$(ADLB)/lib
RPATHS += -Wl,-rpath -Wl,$(C_UTILS)/lib
RPATHS += -Wl,-rpath -Wl,$(MPI_LIB_DIR)
RPATHS += -Wl,-rpath -Wl,$(TCL_LIB_DIR)
ifeq ($(ENABLE_MPE),1)
	RPATHS += -Wl,-rpath -Wl,$(USE_MPE)/lib
endif
ifeq ($(HAVE_PYTHON),1)
	ifneq ($(USE_PYTHON_LIBDIR),0)
		RPATHS += -Wl,-rpath -Wl,$(USE_PYTHON_LIBDIR)
	endif
endif
ifeq ($(HAVE_R),1)
	RPATHS += -Wl,-rpath -Wl,$(R_LIB)
endif

### INCLUDES

DIR :=
TURBINE_SRC :=
TCL_TURBINE_SRC :=
STATIC_PKG_SRC :=
TURBINE_EXECUTABLE_MANIFESTS :=

include src/turbine/module.mk
include src/util/module.mk
include src/tcl/module.mk
include src/tcl/c-utils/module.mk
include src/tcl/adlb/module.mk
include src/tcl/blob/module.mk
include src/tcl/mpe/module.mk
include src/tcl/python/module.mk
include src/tcl/r/module.mk
include src/tcl/static-pkg/module.mk
include src/tcl/turbine/module.mk
include lib/module.mk
include libstatic/module.mk
include scripts/submit/module.mk
include src/executables/module.mk

TURBINE_SRC += $(TCL_ADLB_SRC)
TURBINE_SRC += $(TCL_C_UTILS_SRC)
TURBINE_SRC += $(TCL_BLOB_SRC)
TURBINE_SRC += $(TCL_MPE_SRC)
TURBINE_SRC += $(TCL_PYTHON_SRC)
TURBINE_SRC += $(TCL_R_SRC)
TURBINE_SRC += $(TCL_TURBINE_SRC)
TURBINE_OBJS = $(patsubst %.c, %.o, $(TURBINE_SRC))

STATIC_PKG_OBJS = $(patsubst %.c, %.o, $(STATIC_PKG_SRC))

STATIC_PKG_RESOURCE_C := $(patsubst %.tcl, %_tcl.c, $(TCL_SRC))
STATIC_PKG_RESOURCE_O := $(patsubst %.c, %.o, $(STATIC_PKG_RESOURCE_C))
STATIC_PKG_RESOURCE_H := src/tcl/static-pkg/tcl-turbine-src.h

TURBINE_EXECUTABLE_SRC := $(patsubst %.manifest, %.c, $(TURBINE_EXECUTABLE_MANIFESTS))
TURBINE_EXECUTABLE_OBJS = $(patsubst %.c, %.o, $(TURBINE_EXECUTABLE_SRC))
TURBINE_EXECUTABLES := $(patsubst %.c, %, $(TURBINE_EXECUTABLE_SRC))

### DEPENDENCIES

TURBINE_DEPS := $(patsubst %.c, %.d, $(TURBINE_SRC))

TURBINE_EXECUTABLE_DEPS := $(patsubst %.c, %.d, $(TURBINE_EXECUTABLE_SRC))
TURBINE_EXECUTABLE_DEPS += $(patsubst %.manifest, %.manifest.d, \
			     $(TURBINE_EXECUTABLE_MANIFESTS))
TURBINE_EXECUTABLE_DEPS += $(patsubst %.manifest, %.x.d, \
			     $(TURBINE_EXECUTABLE_MANIFESTS))

STATIC_PKG_DEPS := $(patsubst %.c, %.d, $(STATIC_PKG_SRC))

TEST_SRC_MANIFEST :=
TEST_SRC :=
include tests/module.mk
TEST_DEPS := $(patsubst %.c, %.d, $(TEST_SRC))
TEST_DEPS += $(patsubst %.manifest, %.manifest.d, $(TEST_SRC_MANIFEST))
TEST_DEPS += $(patsubst %.manifest, %.x.d, $(TEST_SRC_MANIFEST))

# Dependency files:
# Remember that having a bad #include can cause dependency
# file generation to fail silently
# Solution: use target check_includes
DEPS := $(TURBINE_DEPS) $(TURBINE_EXECUTABLE_DEPS) $(TEST_DEPS) $(STATIC_PKG_DEPS)

deps: $(DEPS)

%.d: %.c
	$(Q) "  DEP		$(@)"
	$(E) CC="$(CC)" $(srcdir)/maint/depend.sh \
             $(call dirname, $(*)) $(<) $(@) $(CFLAGS)

ifeq (,$(filter clean deps,$(MAKECMDGOALS)))
 -include $(DEPS)
endif

# Extract all files from *.d files, format and sort:
# Formats to one file per line & extracts junk and extra files in *.d
deps.txt: $(DEPS)
	$(Q) "  DEPS.TXT "
	$(E) maint/collect.sh $(@) $(DEPS)

# Check existing *.d files for files that do not exist
# Useful when dependency file generation is failing
# Must "make clean" to re-check correctly
EXISTING_D = $(shell find . -name *.d)

check_includes: deps_contents.txt
	$(Q) "  CHECK.SH"
	$(E) $(srcdir)/maint/check.sh deps_contents.txt

deps_contents.txt:
	$(Q) "  SH		$(@)"
	$(E) $(srcdir)/maint/collect.sh $(@) $(EXISTING_D)

### TAGS

tags: TAGS

TAGS: deps.txt
	$(Q) "  TAGS "
	$(E) etags `cat deps.txt`

### COMPILE

%.o: %.c
# This line produces a false autoscan message on token 'CC' (C++)
	$(Q) "  CC		$(@)"
	$(E) $(CC) $(CFLAGS) \
             -c $(<) -o $(@)

### LINK

# This rule produces a false autoscan message on token 'install'
$(TCL_TURBINE_A): $(TURBINE_OBJS)
ifeq ($(ENABLE_STATIC),0)
	@echo "Static libraries were disabled, cannot build target!"
	@exit 1
endif
	$(Q) "  AR		$(@)"
	$(E) $(AR) $(ARFLAGS) $(@) $(TURBINE_OBJS)
	$(E) $(RANLIB) $(@)

$(TCL_TURBINE_SO): $(TURBINE_OBJS)
ifeq ($(ENABLE_SHARED),0)
	@echo "Shared libraries were disabled, cannot build target!"
	@exit 1
endif
	$(Q) "  LINK		$(@)"
	$(E) $(CC) $(SHARED) $(LDFLAGS) -o $(@) \
             $(TURBINE_OBJS) \
             $(LIBS) \
             $(RPATHS) \
             $(MAC_NAME)

$(STATIC_PKG_A): $(STATIC_PKG_OBJS)
ifeq ($(ENABLE_STATIC),0)
	@echo "Static libraries were disabled, cannot build target!"
	@exit 1
endif
	$(Q) "  AR		$(@)"
	$(E) $(AR) $(ARFLAGS) $(@) $(STATIC_PKG_OBJS)
	$(E) $(RANLIB) $(@)

### TCL SOURCE LINKING
# Compilation and linking to get Tcl source as C arrays

F2A := scripts/mkstatic/file2array.sh
F2A_MKHDR := scripts/mkstatic/files2arrays_mkhdr.sh

$(STATIC_PKG_RESOURCE_C): %_tcl.c : %.tcl $(F2A)
	$(Q) "  FILE2ARRAY $(@)"
	$(E) $(F2A) -v "turbine_lib_$(shell basename $< | sed 's/[\.-]/_/g')" $< > $(@)

$(STATIC_PKG_RESOURCE_H): $(STATIC_PKG_RESOURCE_C) $(F2A_MKHDR)
	$(Q) " MKHDR $(@)"
	$(E) $(F2A_MKHDR) turbine_lib_src $(STATIC_PKG_RESOURCE_C) > $(@)

# Regular .o compilation rule generates .o files

$(STATIC_PKG_RESOURCE_A): $(STATIC_PKG_RESOURCE_O)
	$(Q) "  AR		$(@)"
	$(E) $(AR) $(ARFLAGS) $(@) $(STATIC_PKG_RESOURCE_O)
	$(E) $(RANLIB) $(@)

### LINK EXECUTABLES

executables: $(TURBINE_EXECUTABLES)

# TODO: get configure to check if static libraries are present
# List out static libs.  If A depends on B, A must come first.
# These are provided to linker first, so take precedence over
# any dynamic versions of the libraries that may also be mentioned
STATIC_LIBS :=
STATIC_LIBS += $(STATIC_PKG_A)
STATIC_LIBS += $(STATIC_PKG_RESOURCE_A)
STATIC_LIBS += $(TCL_TURBINE_A)
STATIC_LIBS += $(ADLB)/lib/libadlb.a
STATIC_LIBS += $(C_UTILS)/lib/libexmcutils.a
ifneq ($(strip $(TCL_LIB_A)),)
	STATIC_LIBS += $(TCL_LIB_A)
endif
# TODO: support more than just Mpich
STATIC_LIBS += ${MPI_LIB_DIR}/libmpich.a
STATIC_LIBS += ${MPI_LIB_DIR}/libmpl.a

# Transitive shared library dependencies
# TODO: more elegant solution
TRANSITIVE_LIB_DEPS_SHARED = -lpthread -ldl -lm
TRANSITIVE_LIB_DEPS_STATIC = -lz 

# Export Tcl API symbols to link with dynamically loaded modules.
# Needed to support dynamically loading Tcl modules from our binary
# NOTE: can prevent symbols being re-exported from libraries, e.g. 
#	-Wl,--exclude-libs,c
LD_EXEC_SYMBOL_EXPORT = -Wl,--export-dynamic

# Rule to build C source file based on manifest
# Also create deps file so it can be correctly recreated upon change.
%.c: %.manifest %.manifest.d %.x.d $(MKSTATIC) $(MKSTATIC_TEMPLATE)
	$(Q) "  MKSTATIC	$(@)"
	$(E) $(MKSTATIC_RUN) $< -c $(@) \
	      --link-deps $(patsubst %.manifest, %.x.d, $<) \
			  $(patsubst %.manifest, %.x, $<)

%.manifest.d: %.manifest $(MKSTATIC) $(MKSTATIC_TEMPLATE)
	$(Q) "  MKSTATIC_DEPS	$(@)"
	$(E) $(MKSTATIC_RUN) $< \
	  --deps $(@) $(patsubst %.manifest, %.c, $<)

# Dependency rules for executable with .x or no extension
%.x.d: %.manifest $(MKSTATIC) $(MKSTATIC_TEMPLATE)
	$(Q) "  LINK_DEPS	$(@)"
	$(E) $(MKSTATIC_RUN) $< --link-deps $(@) \
			  $(patsubst %.manifest, %.x, $<)
	$(E) $(MKSTATIC_RUN) $< --link-deps $(@) \
			  $(patsubst %.manifest, %, $<)

%/pkgIndex.tcl: %.manifest $(MKSTATIC)
	$(Q) "  MKSTATIC	$(@)"
	$(E) mkdir -p $(shell dirname $(@))
	$(E) $(MKSTATIC_RUN) $< -p $(@)


# Binary executables - link from .o
# Currently builds a dynamically linked executable 
# Link statically where possible by adding static libs explicitly.
#   Static libs must be compiled with -fPIC or -fPIE
$(TURBINE_EXECUTABLES): %: %.o ${STATIC_LIBS} ${STATIC_PKG_RESOURCE_H} $(TCL_API_SYMBOLS_LD)
	$(Q) "  LINK		$(@)"
	$(E) $(CC) $(<) $(LDFLAGS) $(LD_EXEC_SYMBOL_EXPORT) \
	$(shell $(MKSTATIC_RUN) "$(@).manifest" --ignore-no-manifest --link-objs) \
	$(STATIC_LIBS) \
	$(shell $(MKSTATIC_RUN) "$(@).manifest" --ignore-no-manifest --link-flags) \
	-Wl,-Bstatic $(TRANSITIVE_LIB_DEPS_STATIC) -Wl,-Bdynamic \
	$(TRANSITIVE_LIB_DEPS_SHARED) \
        $(MAC_FLAT) \
	$(LIBS) \
	$(RPATHS) \
	-o $(@)

### TESTS

# Test cases in C as objects
TEST_OBJS = $(patsubst %.c, %.o, $(TEST_SRC_C))
# Test cases in C compiled to binary
TEST_BINS = $(patsubst %.c, %.x, $(TEST_SRC_C))
# Test case results
TEST_SCRIPTS = $(patsubst %.c, %.sh, $(TEST_SRC_C))
# Test case outputs
TEST_OUTPUT  := $(patsubst %.c,   %.out, $(TEST_SRC_C))
TEST_OUTPUT  += $(patsubst %.tcl, %.out, $(TEST_SRC_TCL))
# Test case results
TEST_RESULTS := $(patsubst %.c,   %.result, $(TEST_SRC_C))
TEST_RESULTS += $(patsubst %.tcl, %.result, $(TEST_SRC_TCL))

# Target to just build all C tests
tests: $(TEST_BINS)

# Run all tests
test_results: $(TEST_RESULTS)

# Binary executables in the test suite
$(TEST_BINS): %.x: %.o install.txt $(STATIC_PKG_A) $(STATIC_PKG_RESOURCE_A)
	$(Q) "  LINK		$(@)"
	$(E) $(CC) $(<) \
	$(shell $(MKSTATIC_RUN) "$(@).manifest" --ignore-no-manifest --link-objs) \
	$(STATIC_PKG_A) $(STATIC_PKG_RESOURCE_A) \
        $(MAC_FLAT) \
	$(shell $(MKSTATIC_RUN) "$(@).manifest" --ignore-no-manifest --link-flags) \
	-L$(INSTALL_LIB) -ltclturbine \
	$(LIBS) -L $(TCL_LIB_DIR) -l$(TCL_LIB_NAME) \
	$(RPATHS) \
	-o $(@)

# Test result rule for C tests
%.result: %.sh %.x install.txt
#       Cannot use chmod in config.status
	$(E) chmod u+x tests/runbin.zsh
	$(Q) "  SH		$(@)"
	$(E) mkdir -p tests/data
	$(E) rm -f $(@)
	$(E) $(<) > $(*).tmp 2>&1
	$(E) mv $(*).tmp $(@) 2>&1

# Test result rule for Tcl tests
%.result: %.sh %.tcl $(PACKAGE) bin/turbine install.txt
	$(Q) "  SH		$(@)"
	$(E) mkdir -p tests/data
#       Remove old result if present
	$(E) rm -f $(@)
#       Run test script: %.sh
	$(E) LAUNCH=$(LAUNCHER) $(<) > $(*).tmp 2>&1
#       Check for valgrind errors
	$(E) ! grep -q "==[0-9]+==" $(*).out
#       Success: create result file
	$(E) mv $(*).tmp $(@)

### INSTALL

HAVE_CP_U = @CP_U@
ifeq ($(HAVE_CP_U),yes)
	CP_ARGS = -uvf
else
	CP_ARGS = -vf
endif

HAVE_CP_PARENTS = @CP_PARENTS@
ifeq ($(HAVE_CP_PARENTS),yes)
	CP_PARENTS = cp --parents
else
	CP_PARENTS = maint/cp-parents.sh
endif

# These files will be copied to the installation directory
PROVENANCE = version.txt source.txt config.log

# Maintaining the install.txt file is a simple way to
# create a dependency on the installation
install: install.txt

# Installed files:
DIRECTORIES = $(INSTALL_PREFIX) $(INSTALL_BIN) $(INSTALL_ETC)     \
              $(INSTALL_EXPORT) $(INSTALL_INCLUDE) $(INSTALL_LIB) \
	      $(INSTALL_LIBSTATIC) $(INSTALL_SCRIPTS)

TURBINE_HEADERS := src/turbine/turbine.h      \
		  src/tcl/turbine/tcl-turbine.h \
                  src/turbine/turbine-defs.h \
                  src/tcl/blob/blob.h
ifeq ($(ENABLE_STATIC),1)
  TURBINE_HEADERS += $(STATIC_PKG_RESOURCE_H)
endif

BINS    = $(shell ls bin/turbine \
                     bin/turbine-write-doubles \
                     bin/turbine-read-doubles ) \
          $(TURBINE_EXECUTABLES)
EXPORTS = $(shell ls export/*.swift )
SCRIPTS = $(shell ls scripts/*.zsh scripts/*.sh scripts/*.tcl \
		     scripts/mkstatic/* $(SCRIPTS_SUBMIT) )

install.txt: $(ENABLED_PACKAGES) $(BINS) $(EXPORTS) $(SCRIPTS) $(TURBINE_HEADERS)
#       Note: this is re-run if anything changes
	@echo
	$(Q) "  INSTALL		$(INSTALL_PREFIX)"
	$(E) rm -f $(@)
#       Set up directories
	$(E) mkdir -pv $(DIRECTORIES)
#       Copy in build provenance files
	$(E) cp $(CP_ARGS) $(PROVENANCE) $(INSTALL_ETC)
#       Copy Turbine items
	$(E) cp $(CP_ARGS) $(BINS)               $(INSTALL_BIN)
ifeq ($(ENABLE_SHARED),1)
	$(E) cp $(CP_ARGS) lib/*.tcl             $(INSTALL_LIB)
endif
ifeq ($(ENABLE_STATIC),1)
	$(E) cp $(CP_ARGS) libstatic/*.tcl       $(INSTALL_LIBSTATIC)
endif
	$(E) cp $(CP_ARGS) $(TCL_TURBINE_LIBS)    $(INSTALL_LIB)
	$(E) $(CP_PARENTS) $(CP_ARGS) $(SCRIPTS) $(INSTALL_PREFIX)
	$(E) $(CP_PARENTS) $(CP_ARGS) $(EXPORTS) $(INSTALL_PREFIX)
	$(E) cp $(CP_ARGS) $(TURBINE_HEADERS)    $(INSTALL_INCLUDE)
	$(E) cp $(CP_ARGS) etc/help.txt          $(INSTALL_ETC)
	@echo
	$(Q) "  CREATE 		$(@)"
	$(E) echo  "PREFIX: $(INSTALL_PREFIX)"   >  $(@)
	$(E) echo  "SOURCE: $(PWD)"              >> $(@)
	$(E) date "+DATE:   %m/%d/%Y %I:%M%p"    >> $(@)
#       Use true to ignore errors (if this is not an SVN checkout)
	$(E) ( svn info | grep Revision ; true ) >> $(@) 2>&1
	$(E) cp $(CP_ARGS) $(@) $(INSTALL_PREFIX)

### Autoconf sanity:

Makefile: configure.ac
	@echo "Configuration is not up to date!"
	@echo "Run ./setup.sh and ./configure again."
	@exit 1

### CLEAN

clean::
	@echo
	@echo "  CLEAN"
	@rm -fv  $(PACKAGE) $(PACKAGE_STATIC) install.txt
	@rm -fv  $(TURBINE_A) $(TCL_TURBINE_SO)
	@rm -fv  $(STATIC_PKG_A) $(STATIC_PKG_RESOURCE_A)
	@rm -fv  $(DEPS) $(TEST_DEPS) deps.txt deps_contents.txt TAGS
	@rm -fv  $(TEST_BINS) $(TEST_OBJS) $(TEST_OUTPUT)
	@rm -fv  $(TEST_RESULTS)
	@rm -fv  $(TURBINE_OBJS) $(STATIC_PACKAGE_OBJS)
	@rm -fv  $(TURBINE_SRC_A) $(STATIC_PKG_RESOURCE_O)
	@rm -fvr tests/data

# Clean *.result files that did not succeed
clean-failed:
	@rm -fv `grep -L "exit 0" **/*.result`

distclean:: clean
	@rm -fv Makefile **/*.mk
	@rm -fv src/turbine/turbine-version.h
	@rm -fv scripts/turbine-config.sh
	@rm -fv system-libs.txt

.PHONY: clean install package test_results

### DEBUG BUILD SYSTEM

# Useful target when debugging the build system
debug_build:
	@echo DEPS: $(DEPS)
	@echo TURBINE_SRC: $(TURBINE_SRC)
	@echo TURBINE_OBJS: $(TURBINE_OBJS)
	@echo TESTS: $(TESTS)
