
TURBINE_VERSION = @TURBINE_VERSION@

PACKAGE = lib/pkgIndex.tcl

all: package

turbine: $(TURBINE)

package: $(PACKAGE)

USE_MAC = @USE_MAC@

INSTALL_PREFIX  = @prefix@
INSTALL_BIN     = $(INSTALL_PREFIX)/bin
INSTALL_ETC     = $(INSTALL_PREFIX)/etc
INSTALL_INCLUDE = $(INSTALL_PREFIX)/include
INSTALL_LIB     = $(INSTALL_PREFIX)/lib
INSTALL_SCRIPTS = $(INSTALL_PREFIX)/scripts
INSTALL_EXPORT  = $(INSTALL_PREFIX)/export
# The submit scripts are loaded from their respective module.mk files
SCRIPTS_SUBMIT  :=

# Shared object suffix is .so on Linux, .dylib on Mac
# GCC shared library creation argument
# Linux: -shared; Mac: -dynamiclib
# Use -flat_namespace on the Mac
ifeq ($(USE_MAC),no)
	USE_XLC = @USE_XLC@
	ifeq ($(USE_XLC),0)
#       	Not XLC: GCC/Linux
		PIC = -fPIC
		STD = -std=gnu99
		SHARED = -shared
		WARNS = -Wall -Wconversion
	else
#       	Using XLC
		PIC = -qpic
		STD =
		SHARED = -qmkshrobj -qnostaticlink -qnostaticlink=libgcc
		WARNS =
	endif

	SO_SUFFIX = so
	MAC_FLAT =
	MAC_NAME =
else
# 	Mac
	STD = -std=gnu99
	SO_SUFFIX = dylib
	MAC_FLAT = -Wl,-flat_namespace
	MAC_NAME = -install_name $(INSTALL_LIB)/libtclturbine.dylib
	SHARED = -dynamiclib $(MAC_FLAT)
endif

TCL_TURBINE_SO = lib/libtclturbine.$(SO_SUFFIX)

# Used only for testing:
TURBINE_A = lib/libturbine.a

tcl_turbine: $(TCL_TURBINE_SO)

srcdir = @srcdir@

ifeq ($(V),1)
	QUIET_COMPILE = 0
else
	QUIET_COMPILE = 1
endif

ifeq ($(QUIET_COMPILE),1)
  # Prints a short description of the action, does not show command
  Q=@echo
  E=@
else
  # Echoes the entire command
  Q=@echo >/dev/null
  E=
endif

CC = @CC@
CFLAGS := @CFLAGS@

# Set includes
CFLAGS += -I . -I src/turbine
ifeq ($(USE_XLC),1)
	CFLAGS += -qpack_semantic=gnu
endif

C_UTILS = @USE_C_UTILS@

TCL := @USE_TCL@
TCL_VERSION := @TCL_VERSION@
TCLSH := @USE_TCLSH@
TCL_LIB_DIR := @USE_TCL_LIB_DIR@
TCL_LIB_NAME := tcl$(TCL_VERSION)
TCLSH_LOCAL := @USE_TCLSH_LOCAL@

MACHINE = @USE_MACHINE@

# On some systems, the user will use mpicc,
# on others, the user will specify the MPI include and lib paths
MPI_INCLUDE = @USE_MPI_INCLUDE@
MPI_LIB_DIR = @USE_MPI_LIB_DIR@
MPI_LIB_NAME = @USE_MPI_LIB_NAME@
# The actual linker arguments:
CFLAGS += -I $(MPI_INCLUDE)
MPI_LIB	:= -L$(MPI_LIB_DIR) -l $(MPI_LIB_NAME)
           # -l mpl # Needed for older MPICH

LAUNCHER = @USE_LAUNCHER@

ADLB = @USE_ADLB@
ifneq ($(ADLB),0)
	CFLAGS += -I $(ADLB)/include
endif

ENABLE_MPE = @ENABLE_MPE@
USE_MPE = @USE_MPE@

HAVE_PYTHON        = @HAVE_PYTHON@
USE_PYTHON_INCLUDE = @USE_PYTHON_INCLUDE@
USE_PYTHON_LIBDIR  = @USE_PYTHON_LIBDIR@
USE_PYTHON_NAME    = @USE_PYTHON_NAME@

HAVE_R = @HAVE_R@
USE_R  = @USE_R@

CFLAGS += $(STD)
CFLAGS += -g
CFLAGS += $(WARNS)
CFLAGS += $(PIC)
# This is referenced in lookup3.c - may want to drop this for speed
CFLAGS += -D VALGRIND
CFLAGS += -I $(C_UTILS)/include
CFLAGS += @TCL_INCLUDE_SPEC@
ifeq ($(ENABLE_MPE),1)
	CFLAGS += -I $(USE_MPE)/include
endif
ifeq ($(HAVE_PYTHON),1)
	CFLAGS += -I $(USE_PYTHON_INCLUDE)
endif
ifeq ($(HAVE_R),1)
	CFLAGS += -I $(USE_R)/include
endif

# LIBS: links to ADLB, c-utils, MPE, and MPI
LIBS :=
LIBS += -L$(ADLB)/lib -l adlb
LIBS += -L$(C_UTILS)/lib -l exmcutils
LIBS += -L$(TCL_LIB_DIR) -l$(TCL_LIB_NAME)
ifeq ($(ENABLE_MPE),1)
	LIBS += -L$(USE_MPE)/lib -l mpe
endif
LIBS += $(MPI_LIB)
ifeq ($(HAVE_PYTHON),1)
	ifneq ($(USE_PYTHON_LIBDIR),0)
		LIBS += -L$(USE_PYTHON_LIBDIR)
	endif
	LIBS += -l$(USE_PYTHON_NAME)
endif
ifeq ($(HAVE_R),1)
	R_LIB = $(USE_R)/lib
	LIBS += -L$(R_LIB) -lR
endif

dirname = $(patsubst %/,%,$(dir $(1)))

RPATHS :=
RPATHS += -Wl,-rpath -Wl,$(INSTALL_LIB)
RPATHS += -Wl,-rpath -Wl,$(ADLB)/lib
RPATHS += -Wl,-rpath -Wl,$(C_UTILS)/lib
RPATHS += -Wl,-rpath -Wl,$(MPI_LIB_DIR)
RPATHS += -Wl,-rpath -Wl,$(TCL_LIB_DIR)
ifeq ($(ENABLE_MPE),1)
	RPATHS += -Wl,-rpath -Wl,$(USE_MPE)/lib
endif
ifeq ($(HAVE_PYTHON),1)
	ifneq ($(USE_PYTHON_LIBDIR),0)
		RPATHS += -Wl,-rpath -Wl,$(USE_PYTHON_LIBDIR)
	endif
endif
ifeq ($(HAVE_R),1)
	RPATHS += -Wl,-rpath -Wl,$(R_LIB)
endif

### INCLUDES

DIR :=
TURBINE_SRC :=
TCL_TURBINE_SRC :=
include src/turbine/module.mk
include src/util/module.mk
include src/tcl/module.mk
include src/tcl/c-utils/module.mk
include src/tcl/adlb/module.mk
include src/tcl/blob/module.mk
include src/tcl/mpe/module.mk
include src/tcl/python/module.mk
include src/tcl/r/module.mk
include src/tcl/turbine/module.mk
include lib/module.mk
include scripts/submit/module.mk

TURBINE_SRC += $(TCL_ADLB_SRC)
TURBINE_SRC += $(TCL_C_UTILS_SRC)
TURBINE_SRC += $(TCL_BLOB_SRC)
TURBINE_SRC += $(TCL_MPE_SRC)
TURBINE_SRC += $(TCL_PYTHON_SRC)
TURBINE_SRC += $(TCL_R_SRC)
TURBINE_SRC += $(TCL_TURBINE_SRC)
TURBINE_OBJS = $(patsubst %.c, %.o, $(TURBINE_SRC))

### DEPENDENCIES

TURBINE_DEPS := $(patsubst %.c, %.d, $(TURBINE_SRC))

TEST_SRC :=
include tests/module.mk
TEST_DEPS := $(patsubst %.c, %.d, $(TEST_SRC))

# Dependency files:
# Remember that having a bad #include can cause dependency
# file generation to fail silently
# Solution: use target check_includes
DEPS := $(TURBINE_DEPS) $(TEST_DEPS)

deps: $(DEPS)

%.d: %.c
	$(Q) "  DEP		$(@)"
	$(E) CC="$(CC)" $(srcdir)/maint/depend.sh \
             $(call dirname, $(*)) $(<) $(@) $(CFLAGS)

ifeq (,$(filter clean deps,$(MAKECMDGOALS)))
 -include $(DEPS)
endif

# Extract all files from *.d files, format and sort:
# Formats to one file per line & extracts junk and extra files in *.d
deps.txt: $(DEPS)
	$(Q) "  DEPS.TXT "
	$(E) maint/collect.sh $(@) $(DEPS)

# Check existing *.d files for files that do not exist
# Useful when dependency file generation is failing
# Must "make clean" to re-check correctly
EXISTING_D = $(shell find . -name *.d)

check_includes: deps_contents.txt
	$(Q) "  CHECK.SH"
	$(E) $(srcdir)/maint/check.sh deps_contents.txt

deps_contents.txt:
	$(Q) "  SH		$(@)"
	$(E) $(srcdir)/maint/collect.sh $(@) $(EXISTING_D)

### TAGS

tags: TAGS

TAGS: deps.txt
	$(Q) "  TAGS "
	$(E) etags `cat deps.txt`

### COMPILE

%.o: %.c
# This line produces a false autoscan message on token 'CC' (C++)
	$(Q) "  CC		$(@)"
	$(E) $(CC) $(CFLAGS) \
             -c $(<) -o $(@)

### LINK

# This rule produces a false autoscan message on token 'install'
$(TURBINE_A): $(TURBINE_OBJS)
	$(Q) "  AR		$(@)"
	$(E) install -d lib
	$(E) ar rcs $(@) $(TURBINE_OBJS)

$(TCL_TURBINE_SO): $(TURBINE_OBJS)
	$(Q) "  LINK		$(@)"
	$(E) $(CC) $(SHARED) $(LDFLAGS) -o $(@) \
             $(TURBINE_OBJS) \
             $(LIBS) \
             $(RPATHS) \
             $(MAC_NAME)

### TESTS

# Test cases in C as objects
TEST_OBJS = $(patsubst %.c, %.o, $(TEST_SRC_C))
# Test cases in C as dependency files
TEST_DEPS = $(patsubst %.c, %.d, $(TEST_SRC_C))
# Test cases in C compiled to binary
TEST_BINS = $(patsubst %.c, %.x, $(TEST_SRC_C))
# Test case results
TEST_SCRIPTS = $(patsubst %.c, %.sh, $(TEST_SRC_C))
# Test case outputs
TEST_OUTPUT  := $(patsubst %.c,   %.out, $(TEST_SRC_C))
TEST_OUTPUT  += $(patsubst %.tcl, %.out, $(TEST_SRC_TCL))
# Test case results
TEST_RESULTS := $(patsubst %.c,   %.result, $(TEST_SRC_C))
TEST_RESULTS += $(patsubst %.tcl, %.result, $(TEST_SRC_TCL))

# Target to just build all C tests
tests: $(TEST_BINS)

# Run all tests
test_results: $(TEST_RESULTS)

# Binary executables in the test suite
$(TEST_BINS): %.x: %.o install.txt
	$(Q) "  LINK		$(@)"
	$(E) $(CC) $(<) \
        $(MAC_FLAT) \
	-L$(INSTALL_LIB) -l tclturbine \
	$(LIBS) -L $(TCL_LIB_DIR) -l $(TCL_LIB_NAME) \
	$(RPATHS) \
	-o $(@)

# Test result rule for C tests
%.result: %.sh %.x install.txt
#       Cannot use chmod in config.status
	$(E) chmod u+x tests/runbin.zsh
	$(Q) "  SH		$(@)"
	$(E) mkdir -p tests/data
	$(E) rm -f $(@)
	$(E) $(<) > $(*).tmp 2>&1
	$(E) mv $(*).tmp $(@) 2>&1

# Test result rule for Tcl tests
%.result: %.sh %.tcl $(PACKAGE) bin/turbine install.txt
	$(Q) "  SH		$(@)"
	$(E) mkdir -p tests/data
#       Remove old result if present
	$(E) rm -f $(@)
#       Run test script: %.sh
	$(E) LAUNCH=$(LAUNCHER) $(<) > $(*).tmp 2>&1
#       Check for valgrind errors
	$(E) ! grep -q "==[0-9]+==" $(*).out
#       Success: create result file
	$(E) mv $(*).tmp $(@)

### INSTALL

HAVE_CP_U = @CP_U@
ifeq ($(HAVE_CP_U),yes)
	CP_ARGS = -uvf
else
	CP_ARGS = -vf
endif

HAVE_CP_PARENTS = @CP_PARENTS@
ifeq ($(HAVE_CP_PARENTS),yes)
	CP_PARENTS = cp --parents
else
	CP_PARENTS = maint/cp-parents.sh
endif

# These files will be copied to the installation directory
PROVENANCE = version.txt source.txt config.log

# Maintaining the install.txt file is a simple way to
# create a dependency on the installation
install: install.txt

# Installed files:
DIRECTORIES = $(INSTALL_PREFIX) $(INSTALL_BIN) $(INSTALL_ETC)     \
              $(INSTALL_EXPORT) $(INSTALL_INCLUDE) $(INSTALL_LIB) \
	      $(INSTALL_SCRIPTS)

TURBINE_HEADERS = src/turbine/turbine.h      \
                  src/turbine/turbine-defs.h \
                  src/tcl/blob/blob.h

BINS    = $(shell ls bin/turbine \
                     bin/turbine-write-doubles \
                     bin/turbine-read-doubles )
EXPORTS = $(shell ls export/*.swift )
SCRIPTS = $(shell ls scripts/*.zsh scripts/*.sh scripts/*.tcl \
	             $(SCRIPTS_SUBMIT) )

install.txt: $(PACKAGE) $(BINS) $(EXPORTS) $(SCRIPTS)
#       Note: this is re-run if anything changes
	@echo
	$(Q) "  INSTALL		$(INSTALL_PREFIX)"
	$(E) rm -f $(@)
#       Set up directories
	$(E) mkdir -pv $(DIRECTORIES)
#       Copy in build provenance files
	$(E) cp $(CP_ARGS) $(PROVENANCE) $(INSTALL_ETC)
#       Copy Turbine items
	$(E) cp $(CP_ARGS) $(BINS)               $(INSTALL_BIN)
	$(E) cp $(CP_ARGS) lib/*.tcl             $(INSTALL_LIB)
	$(E) cp $(CP_ARGS) lib/*.$(SO_SUFFIX)    $(INSTALL_LIB)
	$(E) $(CP_PARENTS) $(CP_ARGS) $(SCRIPTS) $(INSTALL_PREFIX)
	$(E) $(CP_PARENTS) $(CP_ARGS) $(EXPORTS) $(INSTALL_PREFIX)
	$(E) cp $(CP_ARGS) $(TURBINE_HEADERS)    $(INSTALL_INCLUDE)
	$(E) cp $(CP_ARGS) etc/help.txt          $(INSTALL_ETC)
	@echo
	$(Q) "  CREATE 		$(@)"
	$(E) echo  "PREFIX: $(INSTALL_PREFIX)"   >  $(@)
	$(E) echo  "SOURCE: $(PWD)"              >> $(@)
	$(E) date "+DATE:   %m/%d/%Y %I:%M%p"    >> $(@)
#       Use true to ignore errors (if this is not an SVN checkout)
	$(E) ( svn info | grep Revision ; true ) >> $(@) 2>&1
	$(E) cp $(CP_ARGS) $(@) $(INSTALL_PREFIX)

### CLEAN

clean::
	@echo
	@echo "  CLEAN"
	@rm -fv  $(PACKAGE) install.txt
	@rm -fv  $(TURBINE_A) $(TCL_TURBINE_SO)
	@rm -fv  $(DEPS) $(TEST_DEPS) deps.txt deps_contents.txt TAGS
	@rm -fv  $(TEST_BINS) $(TEST_OBJS) $(TEST_OUTPUT)
	@rm -fv  $(TEST_RESULTS)
	@rm -fv  $(TURBINE_OBJS)
	@rm -fvr tests/data

# Clean *.result files that did not succeed
clean-failed:
	@rm -fv `grep -L "exit 0" **/*.result`

distclean:: clean
	@rm -fv Makefile **/*.mk
	@rm -fv src/turbine/turbine-version.h
	@rm -fv scripts/turbine-config.sh

.PHONY: clean install package test_results

### DEBUG BUILD SYSTEM

# Useful target when debugging the build system
debug_build:
	@echo DEPS: $(DEPS)
	@echo TURBINE_SRC: $(TURBINE_SRC)
	@echo TURBINE_OBJS: $(TURBINE_OBJS)
	@echo TESTS: $(TESTS)
